# 인터페이스
- 구현을 포함하지 않는 메서드 집합
- 정의한 메서드 집합을 가진 모든 타입은 인터페이스로 사용 가능
- 구체화된 타입이 아닌 인터페이스만 가지고 메서드 호출
- 상호작용면 (interface)
- 메서드 구현을 포함한 구체화된 객체가 아닌 추상화된 객체로 상호작용할 수 있음
- 인터페이스 변수 선언 가능 (변수의 값으로 사용가능)
- 타입
- 추상화(abstraction): 내부 동작(구현)을 감춰서 서비스 제공자와 사용자에게 자유를 주는 방식
- 의존성 Down, 결합도 Up (decoupling)
- 추상계층(Abstract Layer)
- 인터페이스 Field: 인스턴스 메모리 주소, 타입 정보
- 구현이 포함하지 않는 관계 (메서드)

## 인터페이스 선언
- type + 인터페이스명 + inerface키워드 + 중괄호 { 메서드 집합 }
- 메서드명 필수
- 매개변수와 반환이 다르더라도 같은 이름 메서드 불가
- 메서드 구현을 포함X (signiture: 타입, 이름, 출력)

```
type InerfaceName interface {
  Method()
  MethodSet()
  // Method(int) string // ERROR (중복 메서드)
  // _(x int) // ERROR (메서드명 필수)
}
```

### 덕타이핑 (Dock typing)
- 고랭, 파이썬 제공 (자바 제공X)
- 타입 선언시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 인터페이스에 정의한 메서드 포함 여부만으로 결정하는 방식 
- 어떤 새가 오리처럼 걷고 오리처럼 날면 그 새는 오리라고 부르겠다.
- 인터페이스 판단을 사용자가 할 수 있어서 서비스 사용자 중심의 코딩이 가능
- 타입선언시 인터페이스 구현여부를 명시하지 않아도 된다.
- 사용자 중심의 코딩
- 인터페이스 구현 여부를 명시적으로 선언하는게 아닌 인터페이스에서 정의한 메서드 포함 여부로 판단

### 디자인 패턴 (어답터 패턴)
- 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응(변환) 시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다.

### Adapter 패턴 권장
- 두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 서로 다른 경우.
- 두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우.
- 외부 라이브러리라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경우, 또는 인터페이스가 프레임워크의 일부라서 이미 많은 클라이언트에서 사용되고 있는 경우, 또는 소스 코드를 갖고 있지 않는 경우.

### 빈 인터페이스
- interface{}
- 모든 타입이 가능
- 모든 타입을 받고 싶을 때 사용
- type을 알고 싶은 경우는 v.(type) 사용
- 인터페이스 기본값 nil (유효하지 않은 메모리 주소)
  - 기본값 nil인 타입: 포인터, 인터페이스, 함수 타입, 슬라이스, 맵, 채널 등
  - nil 확인 후 사용 (runtime error: 실행 중에 에러)
  - invalid memory address: 유효하지 않은 메모리 주솟값
  - 비정상적인 메모리 주소 접근하다가 에러 발생
- 인터페이스 변수에 .(타입)을 붙여서 변환 `a.(ConcreteType)`

### invalid memory address
- nil 확인 후 사용 (runtime error: 실행 중에 에러)
- 유효하지 않은 메모리 주솟값
- 비정상적인 메모리 주소 접근하다가 에러 발생

## 에러
1. 컴파일 에러 
- compile time error
- 코드를 기계어로 전환하여 실행 파일로 만드는 중에 발생한 에러
- 문법 오류에서 발생
2. 런타임 에러
- 실행 도중 예기치 않은 문제로 발생한 에러
- 문법에는 문제가 없으나 비정상적인 경우 발생

### 인터페이스 타입 변환
- 인터페이스 변수를 다른 구체화된 타입으로 변환
- 인터페이스를 본래의 구체화된 타입으로 복원할 때 사용
- 인터페이스 변수 뒤에 점을 찍고 소괄호() 안에 변경하려는 타입 입력
```go
  var a Interface
  t := a.(ConcreteType)

  // 타입 변환한 결과, 성공여부 (bool) -> 런타임 에러 방지 
  t, ok := a.(ConcreteType)
  if ok {
    ...
  }
  // 한줄로
  if t, ok := a.(ConcreteType); ok {
    ...
  }
```