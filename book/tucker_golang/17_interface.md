# 인터페이스
- 구현을 포함하지 않는 메서드 집합
- 구체화된 타입이 아닌 인터페이스만 가지고 메서드 호출
- 상호작용면 (interface)
- 메서드 구현을 포함한 구체화된 객체가 아닌 추상화된 객체로 상호작용할 수 있음
- 인터페이스 변수 선언 가능 (변수의 값으로 사용가능)
- 타입
- 추상화(abstraction): 내부 동작(구현)을 감춰서 서비스 제공자와 사용자에게 자유를 주는 방식
- 의존성 Down, 결합도 Up (decoupling)
- 추상계층(Abstract Layer)
- 인터페이스 Field: 인스턴스 메모리 주소, 타입 정보

## 인터페이스 선언
- type + 인터페이스명 + inerface키워드 + 중괄호 { 메서드 집합 }
- 메서드명 필수
- 매개변수와 반환이 다르더라도 같은 이름 메서드 불가
- 메서드 구현을 포함X (signiture: 타입, 이름, 출력)

```
type InerfaceName interface {
  Method()
  MethodSet()
  // Method(int) string // ERROR (중복 메서드)
  // _(x int) // ERROR (메서드명 필수)
}
```

### 덕타이핑 (Dock typing)
- 고랭, 파이썬 제공 (자바 제공X)
- 타입 선언시 인터페이스 구현 여부를 명시적으로 나타낼 필요 없이 인터페이스에 정의한 메서드 포함 여부만으로 결정하는 방식 
- 어떤 새가 오리처럼 걷고 오리처럼 날면 그 새는 오리라고 부르겠다.
- 인터페이스 판단을 사용자가 할 수 있어서 서비스 사용자 중심의 코딩이 가능
- 타입선언시 인터페이스 구현여부를 명시하지 않아도 된다.
- 사용자 중심의 코딩


### 디자인 패턴 (어답터 패턴)
- 클래스의 인터페이스를 사용자가 기대하는 인터페이스 형태로 적응(변환) 시킵니다. 서로 일치하지 않는 인터페이스를 갖는 클래스들을 함께 동작시킵니다.

### Adapter 패턴 권장
- 두 클래스가 동일하거나 유사한 작업을 수행하지만 인터페이스가 서로 다른 경우.
- 두 클래스가 공통 인터페이스를 가지면, 클라이언트 코드가 더 간단하고 명료해질 수 있는 경우.
- 외부 라이브러리라서 인터페이스를 바꾸고 싶어도 쉽게 바꿀 수 없는 경우, 또는 인터페이스가 프레임워크의 일부라서 이미 많은 클라이언트에서 사용되고 있는 경우, 또는 소스 코드를 갖고 있지 않는 경우.

### 빈 인터페이스
- interface{}
- 모든 타입이 가능
- 모든 타입을 받고 싶을 때 사용
- type을 알고 싶은 경우는 v.(type) 사용
- 인터페이스 기본값 nil
- 인터페이스 변수에 .(타입)을 붙여서 변환 `a.(ConcreteType)`