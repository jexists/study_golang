
## 슬라이스 (slice)
- 동적 배열: 자동으로 배열 크기를 증가 시키는 자료구조
- 길이가 요소 개수에 따라 자동으로 증가해 관리 편리
- 동적으로 길이 늘어나는 점만 제외하면 배열과 같음
- SliceHeader {Data: unitptr, Len(요소개수): int, Cap(실제 배열의 길이) int}
- 배열 가리키는 포인터, 요소개수(Len), 전체 배열 길이(Cap)으로 구성된 구조체
- 남은 빈 공간 = cap - len
- 남은 공간의 개수가 추가하는 값개수보다 크거나 같은 경우 배열 뒷부분에 값을 추가한 뒤 len값 증가
- 빈공간이 없을 때 (cap) 새로운 기존 배열의 2배 크기로 기존 배열의 요소와 새로운 배열 복사
- cap: 새로운 배열의 길이 값(기존cap*2), len 기존 길이에 추가한 개수, 포인터 새로운 배열
- 슬라이스 내부에 배열을 가리키는 포인터
- append(): 배열의 빈공간이 있을 경우 기존 배열에 추가 / 없을 경우 새로운 기존 배열의 2배 크기 생성 후 추가

### 배열
- 처음 배열때 정한 길이에서 더 이상 늘어나지 않음
```go
package main
import "fmt"
func main() {
	var array [10]int
	fmt.Println(array)
	// [0 0 0 0 0 0 0 0 0 0]

	var slice []int
	if len(slice) == 0 {
		fmt.Println("slice empty ", slice)
		// slice empty  []
	}
	slice[1] = 10 // ERROR
	panic: runtime error: index out of range [1] with length 0
}
```
### 배열 vs 슬라이스
```go 
	var arrayType = [...]int{1, 2, 3} // 배열: 고정길이
	var sliceType = []int{1, 2, 3}    // 슬라이스

	fmt.Println(arrayType)
	fmt.Printf("type of arrayType is %T\n", arrayType)
	// [1 2 3]
	// type of arrayType is [3]int
	fmt.Println(sliceType)
	fmt.Printf("type of sliceType is %T\n", sliceType)
	// [1 2 3]
	// type of sliceType is []int
```

### 슬라이스 초기화
- {}사용해서 초기화
```go
	var slice1 = []int{1, 2, 3}
	var slice2 = []int{1, 5: 2, 10: 3}
	fmt.Println(slice1)
	// [1 2 3]
	fmt.Println(slice2)
	// [1 0 0 0 0 2 0 0 0 0 3]
```

### make() 사용해서 초기화
``` go
	var sliceMake = make([]int, 3)
	fmt.Println(sliceMake) // [0 0 0]
	fmt.Println(len(sliceMake)) // 3 (요소의 개수)
	fmt.Println(cap(sliceMake)) // 3 (실제 배열의 길이)
	fmt.Printf("type of sliceMake is %T\n", sliceMake)
	// type of sliceMake is []int

	var sliceMakeWithCap = make([]int, 3, 5)
	fmt.Println(sliceMakeWithCap) // [0 0 0]
	fmt.Println(len(sliceMakeWithCap)) // 3
	fmt.Println(cap(sliceMakeWithCap)) // 5
```

### append()
- 슬라이스만의 기능
- 요소 추가
- append(추가하고자 하는 슬라이스, 추가하는 요소) = 새로운 슬라이스 결과 반환
- 첫번째 인수로 넣은 값을 ㅕㄴ경하는게 아니라 추가된 새로운 슬라이스 반환
- 기존 슬라이스에 추가하 싶을 경우 대입해서 변경
- 남은 빈 공간 = cap - len
- 남은 공간의 개수가 추가하는 값개수보다 크거나 같은 경우 배열 뒷부분에 값을 추가한 뒤 len값 증가
- 빈공간이 없을 때 (cap) 새로운 기존 배열의 2배 크기로 기존 배열의 요소와 새로운 배열 복사
- cap: 새로운 배열의 길이 값(기존cap*2), len 기존 길이에 추가한 개수, 포인터 새로운 배열
- 슬라이스 내부에 배열을 가리키는 포인터
- append(): 배열의 빈공간이 있을 경우 기존 배열에 추가 / 없을 경우 새로운 기존 배열의 2배 크기 생성 후 추가


### 슬라이싱 Slicing