
## 슬라이스 (slice)
- 동적 배열: 자동으로 배열 크기를 증가 시키는 자료구조
- 길이가 요소 개수에 따라 자동으로 증가해 관리 편리
- 동적으로 길이 늘어나는 점만 제외하면 배열과 같음
- SliceHeader {Data: unitptr, Len(요소개수): int, Cap(실제 배열의 길이) int}
- 배열 가리키는 포인터, 요소개수(Len), 전체 배열 길이(Cap)으로 구성된 구조체
- 남은 빈 공간 = cap - len
- 남은 공간의 개수가 추가하는 값개수보다 크거나 같은 경우 배열 뒷부분에 값을 추가한 뒤 len값 증가
- 빈공간이 없을 때 (cap) 새로운 기존 배열의 2배 크기로 기존 배열의 요소와 새로운 배열 복사
- cap: 새로운 배열의 길이 값(기존cap*2), len 기존 길이에 추가한 개수, 포인터 새로운 배열
- 슬라이스 내부에 배열을 가리키는 포인터
- append(): 배열의 빈공간이 있을 경우 기존 배열에 추가 / 없을 경우 새로운 기존 배열의 2배 크기 생성 후 추가
- 배열의 이루를 나타내는 타입 

### 배열
- 처음 배열때 정한 길이에서 더 이상 늘어나지 않음
```go
package main
import "fmt"
func main() {
	var array [10]int
	fmt.Println(array)
	// [0 0 0 0 0 0 0 0 0 0]

	var slice []int
	if len(slice) == 0 {
		fmt.Println("slice empty ", slice)
		// slice empty  []
	}
	slice[1] = 10 // ERROR
	panic: runtime error: index out of range [1] with length 0
}
```
### 배열 vs 슬라이스
```go 
	var arrayType = [...]int{1, 2, 3} // 배열: 고정길이
	var sliceType = []int{1, 2, 3}    // 슬라이스

	fmt.Println(arrayType)
	fmt.Printf("type of arrayType is %T\n", arrayType)
	// [1 2 3]
	// type of arrayType is [3]int
	fmt.Println(sliceType)
	fmt.Printf("type of sliceType is %T\n", sliceType)
	// [1 2 3]
	// type of sliceType is []int
```

### 슬라이스 초기화
- {}사용해서 초기화
```go
	var slice1 = []int{1, 2, 3}
	var slice2 = []int{1, 5: 2, 10: 3}
	fmt.Println(slice1)
	// [1 2 3]
	fmt.Println(slice2)
	// [1 0 0 0 0 2 0 0 0 0 3]
```

### make() 사용해서 초기화
``` go
	var sliceMake = make([]int, 3)
	fmt.Println(sliceMake) // [0 0 0]
	fmt.Println(len(sliceMake)) // 3 (요소의 개수)
	fmt.Println(cap(sliceMake)) // 3 (실제 배열의 길이)
	fmt.Printf("type of sliceMake is %T\n", sliceMake)
	// type of sliceMake is []int

	var sliceMakeWithCap = make([]int, 3, 5)
	fmt.Println(sliceMakeWithCap) // [0 0 0]
	fmt.Println(len(sliceMakeWithCap)) // 3
	fmt.Println(cap(sliceMakeWithCap)) // 5
```

### append()
- 슬라이스만의 기능
- 요소 추가
- append(추가하고자 하는 슬라이스, 추가하는 요소) = 새로운 슬라이스 결과 반환
- 첫번째 인수로 넣은 값을 ㅕㄴ경하는게 아니라 추가된 새로운 슬라이스 반환
- 기존 슬라이스에 추가하 싶을 경우 대입해서 변경
- 남은 빈 공간 = cap - len
- 남은 공간의 개수가 추가하는 값개수보다 크거나 같은 경우 배열 뒷부분에 값을 추가한 뒤 len값 증가
- 빈공간이 없을 때 (cap) 새로운 기존 배열의 2배 크기로 기존 배열의 요소와 새로운 배열 복사
- cap: 새로운 배열의 길이 값(기존cap*2), len 기존 길이에 추가한 개수, 포인터 새로운 배열
- 슬라이스 내부에 배열을 가리키는 포인터
- append(): 배열의 빈공간이 있을 경우 기존 배열에 추가 / 없을 경우 새로운 기존 배열의 2배 크기 생성 후 추가


### 슬라이싱 Slicing
- 배열의 일부를 집어내는 기능: 슬라이스 반환
- array[startIndex:endIndex]
- 배열의 일부 = 배열[시작인덱스:끝인덱스]
- 배열의 시작인덱스 부터 끝인데스-1 일부 슬라이스 반환
- 새로운 배열이 만들어지는게 아니라 포인터로 가리키는 슬라이스 생성
- 처음부터 슬라이싱: 시작인덱스 생략가능
- 인덱스 2개 사용시 cap: 전체 길이에서 시작 인덱스를 뺀 값 
```go
	slice4 := []int{1, 2, 3,4,5}
	slice5 := slice4[0:3]
	slice6 := slice4[:3]
	// slice4:  [1 2 3 4 5] 5 5
	// slice5:  [1 2 3] 3 3
	// slice6:  [1 2 3] 3 3
```
- 끝까지 슬라이싱: 끝인덱스 생략가능
```go
	slice7 := []int{1, 2, 3, 4, 5}
	slice8 := slice4[2:len(slice7)]
	slice9 := slice4[2:]
	// slice7:  [1 2 3 4 5] 5 5
	// slice8:  [3 4 5] 3 3
	// slice9:  [3 4 5] 3 3
```
- 전체 슬라이싱: 시작인덱스, 끝인덱스 생략가능 (배열 전체를 가리키는 슬라이스 생성)
```go
	slice10 := []int{1, 2, 3, 4, 5}
	slice12 := slice10[0:len(slice10)]
	slice11 := slice10[:]
	// slice10:  [1 2 3 4 5] 5 5
	// slice11:  [1 2 3 4 5] 5 5
	// slice12:  [1 2 3 4 5] 5 5
```
- cap크기 조절
- slice[시작인덱스:끝인덱스:최대인덱스]
```go
	slice13 := []int{1, 2, 3, 4, 5}
	slice14 := slice13[1:3]
	slice15 := slice13[1:3:4]
	// slice13:  [1 2 3 4 5] 5 5
	// slice14:  [2 3] 2 4
	// slice15:  [2 3] 2 3
	slice16 := []int{1, 2, 3, 4, 5, 6, 7, 8}
	slice17 := slice16[1:3]
	slice18 := slice16[1:3:4]
	// slice13:  [1 2 3 4 5 6 7 8] 8 8
	// slice14:  [2 3] 2 7 (최대인덱스: 8 - 시작인덱스: 1)
	// slice15:  [2 3] 2 3 (최대인덱스: 4 - 시작인덱스: 1)
```